-*- mode: org -*- 
#+startup: showall hidestars nofold

* About 
  Toi co rat nhieu y tuong va cong viec can phai ghi nho. Vi vay ma su dung org-mode de thay doi theo y cua minh.
* TODO dbd-complete [[file:~/mydisk/workspace/elisp/db-complete/README.org][README.org]]
  I have create a complete mode for emacs. This had been code from scratch.
** Back-end
   
** Font-end
*** popup.el 
*** fuzzy-matching    
* Emacs initialize
  File [[file:init.org][init.org]] contain the notes for init.el
  
* Emacs reference
* major mode supported
  Each emacs process handle only a major mode to response performance.
** Common 
   This is a org mode with miscellous utils as auto-complete, interface to run other modes, main server on the system ... support some specified functions.
** C/C++
** Clojure
** Java
** Android
** Eclim
** Scheme

* Ontology Web with Emacs 
  [[http://owl-emacs.projects.semwebcentral.org/][An OWL Mode for GNU Emacs]]
** Notice links 
  1. [[http://www.russet.org.uk/blog/2161/comment-page-1]]
  2. [[https://github.com/bdc34/homeConfig/tree/master/dot.emacs-site-lisp/owl]]
  3. [[https://github.com/phillord/tawny-owl]]
  4. 
  5. 
  6.
** Basic concept in emacs programming 
   Emacs has three data structures (actually four) that are intimately related, and very important to understand:
   1. File
      A file is the actual Unix file on disk. You are never editing this file. Rather, you can read a copy into Emacs to initialize a buffer, and write a copy of a buffer out to a file to save it.
   2. Buffer
      A buffer is the internal data structure that holds the text you actually edit. Emacs can have any number of buffers active at any moment. Most, but by no means all, buffers are associated with a file. Buffers have names; a buffer that has been initialized from a file is almost always named for that file, and we say that the buffer is visiting the file. This means, in particular, that when you save the buffer, it's saved to the proper file. At any given time exactly one buffer is selected: this is the buffer that your hardware cursor is in, and this is where commands you type take effect (including self-insert commands). Buffers can be deleted at will; deleting a buffer in no way deletes the file on disk (though you may lose any editing changes you made if you don't save first).
   3. Window
      A window is your view of a buffer. Due to limited screen real-estate, you may not have room to view all your buffers at once. You can split the screen, horizontally or vertically, into as many windows as you like (or at least have room for), each viewing a different buffer. It's also possible to have several windows viewing different portions of the same buffer. Windows can be created and deleted at will; deleting a window in no way deletes the buffer associated with the window. Each window has its own Mode Line, but there's still only one minibuffer.
   4. Frame
      A frame is like a window, but is treated as a separate entity under a windowing system like X. I won't be discussing frames.
   5. * Knowledge as a network
** [[http://www.gnu.org/software/gnowsys/][GNOWSYS: A Kernel for Semantic Computing!]]
** [[http://ceur-ws.org/Vol-514/paper12.pdf][GNOWSYS mode for emacs]]
* Orgmode tutorial [[file:org-notes.org][org-note.org]]
** [[http://orgmode.org/worg/org-tutorials/orgtutorial_dto.html][David O'Toole Org tutorial]]
** [[http://orgmode.org/worg/org-tutorials/org-plot.html][org plot]]
* Git
** git add submodule
   1. git submodule add <path>
   2. or edit .gitmodules
** check out proper commit in your submodules
   git submodule update --recursive
   git submodule foreach git pull origin master
** git remote
   -  add: git remote add <repo-name> <path>
   -  information of all repo: git remote -v
   -  Information of specified repo: git remote show <existent-repo-name>
   -  change url: git remote set-url <existent-repo-name> <path>
   -  rename: git remote rename <existent-repo-name> <new-repo-name>
** git commands
   1. push:
      - git push <existent-repo-name> <branch-name>
      - push data up to remote repository
   2. pull:
      - git pull
      - get data from remote repository and try to merge into current branch
   3. fetch:
      - git fetch <repo-name>
      - get new branch and data from remote repository
* TASK [[file:~/Dropbox/org/todo.org][todo.org]]
* Personal tasks and notes: [[file:~/Dropbox/org/organizer.org][organizer.org]]
* Anything to do with business: [[file:~/Dropbox/org/business.org][business.org]]
* Relationships: [[file:~/Dropbox/org/people.org][people.org]]
* Regular tasks: [[file:~/Dropbox/org/routines.org][routines.org]]
* Outline for future blog posts: [[http://sach.ac/outline][sharing/index.org of Sacha Chua]]  [[file:~/Dropbox/org/blogs/index.org][index.org]]
* Decision review: [[file:~/Dropbox/org/decisions.org][decisions.org]]
* Personal finance: [[file:~/Dropbox/org/ledger.org][ledger.org]]
